Redis クライアントハンドリング
===

このドキュメントでは、ネットワークレイヤー（コネクション、タイムアウト、バッファ、他の類似のトピック）の観点から Redis がどのようにクライアントを扱うか、情報をまとめている。

このドキュメントにある情報は、**Redis 2.6 以降のバージョンが対象である**。


コネクションの確立について
---

Redis はリッスンするように設定された TCPポートおよび Unixソケットに基づきコネクションを受け入れる。新規のコネクションが受け入れられた場合、以下のようなオペレーションが実行される。

* Redis は多重化（multiplexing）およびノンブロッキング I/O であるため、クライアントのソケットがノンブロッキングのステートとなる。
* コネクションに遅延は無いと考えてよいため、`TCP_NODELAY`オプションが設定される。
* *読み込み可能な*ファイルイベントが作成され、ソケットで新しいデータが受信され次第、Redis がクエリを受け取ることができる。
クライアントが初期化されたのち、Redis は並行して扱えるクライアント数が上限に達していないかどうかを確認する（次のセクションで説明するが、これは `maxclients`として設定される）。

その時点で接続しているクライアントの数が最大に達していて接続を受け入れできない場合、Redis はクライアントにその旨のエラーを返し、即座にコネクションを閉じる。
ソケットのアウトプットバッファは通常このようなエラーメッセージを含めるのに十分なサイズなので、このエラーメッセージは Redis がコネクションを閉じたとしてもすぐにクライアントに伝達される。エラーの伝送はカーネルによってハンドリングされる。


クライアントの順序について
---

順序はクライアントソケットファイルのデスクリプター番号と、カーネルがレポートするイベントの並びによって決まる。つまり順序は不定であることを考慮しなくてはならない。

Redis は以下のような挙動をとる。

* クライアントソケットから新しく読みだすたびに、単一の `read()`システムコールを行う。もし複数のクライアントが接続していて、そのうちの幾つかが高い頻度でクエリしている場合にも、他のクライアントが影響を受けたりレイテンシが悪化するといったことはない。
* しかし、新しいデータが読みだされたとき、その時点でバッファ上にあるデータはシーケンシャルに実行される。これによって局所性が向上し、改めてプロセス時間が必要なクライアントの存在を確認する必要がなくなる。


クライアントの最大数
---

Redis 2.4 では並列で処理できるクライアントの最大数はハードコードされていた。

Redis 2.6 では、この上限値は動的になった。デフォルトは 10000クライアントであり、Redis.conf に `maxclients` が設定されていれば、その値が使われる。

しかしながら、Redis はカーネル上でオープン可能なファイルデスクリプターの最大数を確認する（*ソフトリミット*が確認される）。もし Redis で処理したい最大クライアント数より、このリミット（内部的に Redis が利用するファイルデスクリプター数の 32 を考慮した上で）が小さかった場合、Redis は現在の OS上で*実際に扱える*値を上限値として設定する。

最大クライアント数の設定が書き換えられた場合、以下のように起動時にログが出力されるだろう。

```
$ ./redis-server --maxclients 100000
[41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.
```

特定の数のクライアントを処理できるように設定を行っている場合は、OS 側におけるプロセス単位のファイルデスクリプター数についても、それに応じて設定することをお勧めします。

Linux環境下では、以下のようなコマンドで現在のセッションおよびシステム単位の設定を変更することができます。

* ulimit -Sn 100000 # This will only work if hard limit is big enough.
* sysctl -w fs.file-max=100000

アウトプットバッファの上限
---

クライアントに大きなデータを転送するコマンドもあるため、Redis では可変長のアウトプットバッファを扱う必要がある。

ただし、クライアントが多くのコマンドを生成する場合などでは、Redis が既存のアウトプットを返す速度よりも早く次以降のコマンドが到達する場合があります。特に、Pub/Sub を利用していてクライアントが新しいメッセージを十分に早く処理できない場合などで起こりえます。

こういった条件下では、クライアントアウトプットバッファが増加し、メモリ領域がより多く必要になります。このため、デフォルトで Redis はクライアント毎にアウトプットバッファの上限を設定します。この上限に達した場合、コネクションはクローズされ Redis のログファイルにイベントが記録されます。

以下のように 2種類のリミットがあります。

* **ハードリミット**は固定値で、この値に到達した時点でコネクションは即座に閉じられます。

* **ソフトリミット**は時間によって計算され、例えば 10秒あたり 32MB であれば、アウトプットバッファが 32MB を 10秒間超えていたときにコネクションが閉じられる。

クライアントによって異なるデフォルトリミットが設けられている。

* **通常のクライアント**は、デフォルトリミットが 0 であり、つまりリミットは存在しない。ほとんどの一般的なクライアントはブロッキングされる実装、つまり 1つのコマンドを送ったら応答を待ってから次のコマンドを送るようになっている。したがって、このようなクライアントであればコネクションを閉じる必要はない。
* **Pub/Subクライアント**はデフォルトでハードリミットが 32MB、ソフトリミットが 60秒あたり 8MB となっている。
* **スレーブ**はデフォルトでハードリミットが 256MB、ソフトリミットが 60秒あたり 64MB となっている。

これらのリミットは `CONFIG SET`コマンドあるいは永続的な `redis.conf`、いずれかの変更によって変えることができる。設定例は Redis ディストリビューション内の `redis.conf`を参照すること。


クエリ―バッファのハードリミット
---

すべてのクライアントがクエリバッファリミットの対象となる。これは設定変更ができないハードリミットで、クライアントクエリバッファが 1GB に達したらコネクションはクローズされる（バッファはクライアントからのコマンドを蓄積するために利用される）。これは実際のところ、クライアントやソフトウェアのバグによってサーバーがクラッシュすることを防ぐためのリミットである。


クライアントのタイムアウト
---

直近のバージョンのデフォルトでは、Redis はコネクションを閉じることは無い。長期間アイドル状態であってもコネクションは永続的に保持される。

しかしながらこの挙動が好ましくない場合は、タイムアウトパラメータを変更することで、設定した秒数を越えてアイドルを続けているコネクションを閉じることができる。

このリミットは `redis.conf`もしくは単純に `CONFIG SET timeout <value>` で変更できる。

なお、このタイムアウトは通常のクライアントのみに適用され、**Pub/Subクライアントには適用されない**。なぜならば Pub/Sub に関するコネクションは *プッシュ型* であるからだ。

デフォルトでコネクションはタイムアウトしないため、以下のような 2つの条件ではタイムアウトを設定することを考えるべきでしょう。

* ミッションクリティカルなアプリケーション、そのクライアントソフトウェアにバグがあり、Redis がアイドルコネクションを保持し続けることでサービスに影響が出る可能性がある場合

* クライアントソフトウェアのバグによってアイドルコネクションが保持されるケースにおいて、デバッグ目的でサーバに接続するため

タイムアウトは正確ではない点を考慮しなくてはなりません。Redis がタイマーイベントをセットする、あるいは O(N) のアルゴリズムでアイドルコネクションをチェックするといったことを回避するため、チェックはときどき段階的に行われます。これはつまり、タイムアウトが 10秒に設定されているケースにおいて、多数のクライアントが接続していると 12秒後に多数のコネクションが同時に閉じられる、といった可能性があることを意味します。


クライアントのコマンド
---

Redis のコマンドによって、すべてのコネクションの状態について知ることができます。特定のコネクションを kill することもできるし、名前を設定することもできます。Redis を使うときに、これは非常に強力なデバッグツールとなります。

`CLIENT LIST` はコマンドのリストや状態を取得するためのものです。

```
redis 127.0.0.1:6379> client list
addr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
addr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping
```

上記の例では 2つのクライアントが接続しています。それぞれのフィールドの意味は以下の通りです。


* **addr**: クライアントの IPアドレスとポート番号
* **fd**: ソケットファイルのデスクリプタ番号
* **name**: `CLIENT SETNAME`で設定できる名前
* **age**: コネクションが維持されている秒数
* **idle**: アイドルのまま続いている秒数
* **flags**: クライアントの種別（Nは通常のクライアント、等。詳細は [full list of flags](http://redis.io/commands/client-list)）
* **omem**: アウトプットバッファ―のために使われているメモリ量
* **cmd**: 最後に実行したコマンド

フィールドのすべての項目や意味については、[CLIENT LIST](http://redis.io/commands/client-list) のドキュメントも参照のこと。

一度リストを確認したら、`CLIENT KILL`コマンドに IPアドレスを引数として渡して実行することで、特定のクライアントの接続を簡単に閉じることができる。

`CLIENT SETNAME` および `CLIENT GETNAME`コマンドは、コネクションに関して名前を設定したり確認したりするために使われる。Redis 4.0 からは、`SLOWLOG`
 のアウトプットにクライアントの名前が付与されるので、それによって今までよりも簡単に高いレイテンシの原因となっているクライアントを特定できるだろう。


TCPキープアライブ
---

直近のバージョン（3.2以降）では、デフォルトで TCPキープアライブ（`SO_KEEPALIVE`ソケットオプション）が 300秒で有効化されている。このオプションは死んだピアを検出することに役立つ（接続されているように見えてクライアントへの疎通性が失われているケースなどだ）。さらに言えば、クライアントとサーバー間でコネクションを維持するために一定のトラフィックが必要なケースでは、このオプションによって意図しない断を避けることができるだろう。
