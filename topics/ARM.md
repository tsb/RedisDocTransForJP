# ARM 上の Redis

Redis バージョン4.0（執筆時点ではリリース直前）から、Redis は一般的な ARM、特にラズベリーパイを Linux/x86アーキテクチャと同様にサポートしている。つまり、すべての新しいリリースは Pi環境でテスト済みということであり、我々はサポートするデバイスや関連する情報をこのドキュメントにアップデートしていく。アンドロイドでも動作するよう準備を進めていて、将来的にはテストの対象を広げ、公式にサポートできるだろう。

Redis は IoT や組み込みデバイスにとって、いくつかの理由で理想的だと思われる。

* Redis のフットプリントは非常に小さいし、必要とする CPU 性能も小さくて済む。ラズベリーパイゼロのような小さなデバイスでもパフォーマンスに大きな影響を与えず走らせることができ、利用するメモリも小さい上、多くのユースケースで良いパフォーマンスにつながる。
* IoT および組み込みのユースケースにおいて、多くの場合、Redis のデータ構造が活用できる。例えば時系列のデータを蓄積したい場合、実行するコマンドを受け取ったりキューに入れたり、あるいはリモートサーバに応答を送り返したりする。
* Redis 内部でデータをモデリングすることは非常に利用価値が高く、非常に高速な応答が求められるアプライアンスや、リモートサーバがオフラインである場合などに有用である。
* Redis は、デバイス上で動作しているプロセス間のやりとりにも活用できる。
* Append only file は SSD に適した機能である。

## Redis における /proc/cpu/alignment 要件

ARM における Linux では、アラインメントが適切でない場合にトラップしてカーネル内部で修正し、プログラムが SIGBUS を発する代わりに実行を続けられるようになっています。Redis 4.0 以降のバージョンではこの問題に対応済みであり、カーネルで特定の設定を持つ必要はなくなりました。アラインメントを修正する機能がカーネル側で無効になっていても、Redis は問題なく動作します。

## Pi での Redis の構築

* Redis 4.0 ブランチの最新コミットを取得します
* 実行ファイルを作成するため、`make` を実行します

手順に特別なことはありません。デフォルトで唯一の違いは、他の Linux環境でデフォルトで利用される Jemalloc ではなく、libcアロケータを利用することです。この理由ですが、小型の組み込みデバイスなどではメモリフラグメンテーションは問題になりにくいためです。さらに、libcアロケータと比較して、ARM 上で Jemalloc は十分にテストされているとは言えません。

## パフォーマンス

パフォーマンステストはラズベリーパイ 3 および B Pi で行っています。これらの 2つの端末の違いによる性能の差違は非常に大きいものでした。ほとんどのユースケースではネットワーク経由ではなくデバイス内でのやり取りが想定されるため、ベンチマークはループバックインターフェイスを経由して行われました。

ラズベリーパイ 3:

* テスト1 : 十分に分散した 100万のキーで 500万書き込み。永続化なし、パイプラインなし。秒間 28000リクエスト
* テスト2 : テスト1 との違いとして、8 オペレーションをパイプラインでグループ化。秒間 80000リクエスト
* テスト3 : テスト1 との違いとして、fsync 1秒で AOF を有効化。秒間 23000リクエスト
* テスト4 : テスト3 との違いとして、AOF のリライト処理中。秒間 21000リクエスト

ラズベリーパイ 1 モデル B:

* テスト1 : 十分に分散した 100万のキーで 500万書き込み。永続化なし、パイプラインなし。秒間 2200リクエスト
* テスト2 : テスト1 との違いとして、8 オペレーションをパイプラインでグループ化。秒間 8500リクエスト
* テスト3 : テスト1 との違いとして、fsync 1秒で AOF を有効化。秒間 1820リクエスト
* テスト4 : テスト3 との違いとして、AOF のリライト処理中。秒間 1000リクエスト

これらのベンチマークは単純な SET/GET 操作によるものである。Redis における他の高速な操作すべてで似たようなパフォーマンスになるでしょう（線形時間になるものを除く）。しかし、sorted sets に関しては若干の遅延がみられるかもしれません。

