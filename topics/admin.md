Redis アドミニストレーション
===

このページでは Redisインスタンスの管理に関するトピックを扱う。
各トピックは FAQ形式としている。今後、新しいトピックも追加していく。

Redis セットアップのヒント
-----------------

+ Redis のデプロイにあたっては、**Linuxオペレーティングシステム**を推奨する。Redis は OS X でも十分にテストされているし、FreeBSD や OpenBSD でもテストに時間をかけている。しかしながら主だったストレステストはすべて Linux 上で行っているし、多くのプロダクション環境は Linux で動いている
+ Linux カーネルの **overcommit memory 設定は 1** とするように。この設定を反映するには、`vm.overcommit_memory = 1` を `/etc/sysctl.conf` に追記し、`sysctl vm.overcommit_memory=1` を実行するか再起動する。
+ メモリ利用量およびレイテンシの観点で悪影響があるので、Linux カーネルの *transparent huge pages* 機能は無効化する。以下のコマンドを実行して無効化すること: `echo never > /sys/kernel/mm/transparent_hugepage/enabled`
+ **幾らかのスワップ領域をセットアップ**すること（メモリ領域と同じだけのスワップ領域をお勧めする）。Linux環境でスワップ領域がないのに Redis がとても多くのメモリを必要とした場合、Redis が Out of memory でクラッシュするか、Linux カーネルの OOM killer によってプロセスは強制終了されるだろう。
+ 正しい `maxmemory`パラメータを設定することで、メモリが足りなくなった時にエラーを通知させる。
+ もし非常に書き込みが多いアプリケーションで Redis を利用している場合、RDBファイルへの書き込みや AOFログの再構成は **最大で利用メモリの 2倍のメモリが必要になる**ケースがある。このとき追加で必要になるメモリは、ファイルへの保存中に書き込みリクエストが行われたときに変更されたメモリ領域に比例する。つまり、書き込みが行われたキー（あるいは集約されたアイテム）数に比例する。この点を考慮してメモリ領域をサイジングする必要がある。
+ daemontools を利用しているときは `daemonize no` を設定する。
+ 永続化（persistent）を無効化している場合であっても、レプリケーションを利用しているのであれば Redis は RDBファイルへの書き込みを行う。新しいディスクレスのレプリケーションを利用する場合はこの限りではないが、現時点でこの機能は実験的なものとして実装されている。
+ レプリケーションを利用している場合、マスターで永続化を有効化するか、クラッシュ時などに自動的に再起動しないようにしておく。スレーブはマスターの正確なコピーなので、もしマスターが再起動してメモリ上のデータが空になってしまった場合、スレーブも同じ状態になりデータが消えてしまう。
+ デフォルトで Redis は**認証機能を持たず、すべてのネットワークインターフェイスをリッスンする**。Redis がインターネットや任意の攻撃者からアクセス可能である場合、これは大きなセキュリティリスクになる。どれくらい危険かは、例 [this attack](http://antirez.com/news/96) を見てほしい。そのほか、Redis をセキュアにするための情報として [security page](/topics/security) や [quick start](/topics/quickstart) を参照すること。


EC2 上で Redis を稼働させる
--------------------

+ PV ベースではなく、HVM ベースのインスタンスを利用する。
+ 古いインスタンスファミリーを使わないこと。例えば PV の m1.medium ではなく、HVM で m3.medium を使う。
+ Redis の永続化は **EC2 EBS ボリューム** で利用するが、EBS ボリュームはときどきレイテンシが高くなることがあるので、その点には注意すること。
+ もしマスターとスレーブの同期に何らかの問題があった場合には、新しい**ディスクレスレプリケーション**を試してもよい


ダウンタイムなしで Redis インスタンスのアップグレードや再起動を行う
-------------------------------------------------------

Redis は非常に長い期間、プロセスとして稼働できるよう設計されている。利便性のため、多くの設定値は再起動なしで [CONFIG SET command](/commands/config-set) によって適用することができる。

Redis 2.2 からは、AOF から RDB スナップショット永続化への切り替えなどといった変更も、再起動なしで行うことができる。`CONFIG GET *` コマンドの結果も確認してほしい。

しかしながら、再起動は時折ではあるものの定期的に行う必要が出てくる。それは Redis を新しいバージョンにアップグレードするためであったり、CONFIG コマンドでサポートされない設定の変更が必要になる場合などである。

以下の手順は、ダウンタイムを回避するための非常に一般的なものである。

* 新しい Redis 用のインスタンスを立ち上げ、現在稼働している Redis のスレーブにする。たいてい別のサーバーを立ち上げることになると思うが、十分なメモリ領域があるならば同じサーバー内で 2つの Redis を起動してもよい。
* もし単一のサーバーを使っているのであれば、マスターとは異なるポートを設定してスレーブを起動すること。そうでなければマスターのポート設定と干渉するので起動できない。
* 初回のレプリケーションの同期が完了するまで待つ（スレーブ側のログファイルを確認する）。
* INFO コマンドで、マスターと同じだけのキーがスレーブにあることを確認する。redis-cli でスレーブが意図した通りに動作していること、コマンドに応答することを確認する。
* **CONFIG SET slave-read-only no**でスレーブへの書き込みができるようにする。
* すべてのクライアントが新しい Redis を利用するように変更する（それはつまりスレーブ）。
* マスターがクエリを受け取らなくなったことを確認したら（[MONITOR command](/commands/monitor)で確認できる）、**SLAVEOF NO ONE**コマンドでスレーブをマスターに昇格させ、それまでのマスターを停止する。

もし[Redis Sentinel](/topics/) あるいは [Redis Cluster](/topics//topics/cluster-tutorial)を利用している場合、最も簡単にバージョンのアップグレードを行う方法はスレーブを順次アップグレードしていき、手動のフェイルオーバによってマスターをアップグレードされたものに切り替え、最終的に残りのスレーブもすべてアップグレードさせていくという方法になる。

注意すべき点として、Redis クラスター 4.0 と Redis クラスター 3.2 はクラスターバスのプロトコルレベルで互換性がないので、この場合は全台の再起動が必要になるということだ。

