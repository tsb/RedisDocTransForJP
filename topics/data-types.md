データ型
===

<a name="strings"></a>
文字列（Strings）
---

文字列型（Strings）はもっとも基本的なタイプのバリューです。Redis においてはバイナリセーフで、これはつまりどんなデータも含めることができる、ということです。例えば JPEG画像や、シリアライズされた Rubyオブジェクトなど。

文字列型の長さは最大で 512MB となっています。

これを使って、いろいろなことができます。

* アトミックカウンターとして。INCRコマンド群の [INCR](/commands/incr) や [DECR](/commands/decr)、[INCRBY](/commands/incrby) などで活用できます。
* [APPEND](/commands/append)コマンドで文字列の追加もできます
* [GETRANGE](/commands/getrange) や [SETRANGE](/commands/setrange) によって、文字列をランダムアクセスのベクターとして使えます。
* [GETBIT](/commands/getbit) や [SETBIT](/commands/setbit) を使えば、たくさんのデータを整理して格納したり、ブルームフィルタの一部として活用できます。

[文字列に関するコマンドの一覧](/commands/#string) は、[introduction to Redis data types](/topics/data-types-intro) をお読みください。

<a name="lists"></a>
リスト型（Lists）
---

Redis のリスト型はシンプルな文字列のリストで、入力された順に並びます。
左側の頭に新しい要素を挿入したり、右側つまり末尾に要素を追加することもできます。

[LPUSH](/commands/lpush)コマンドは頭に新しい要素を挿入し、[RPUSH](/commands/rpush)コマンドは末尾に新しい要素を追加します。もともと空のキーに対してこれらの操作を行ったときは、新しいリストが作成されます。
同様に、操作を行った時にリストが空になると、キー空間からキーが削除されます。リストコマンドに存在しないキーが渡されたときは、空のリストを渡されたときと同じように動作するためです。

幾つかのリスト操作のサンプルを見てみましょう。

    LPUSH mylist a   # リストは "a" となる
    LPUSH mylist b   # リストは "b","a" となる
    RPUSH mylist c   # リストは "b","a","c" となります（RPUSHが使われているため）

リストの最大長は 2^32 -1 個の要素（4294967295、つまりリスト当たり 4億）です。

リスト型の主な特徴としては、計算量の観点から見たときに、たとえ数百万の要素を持つリストであっても、頭と末尾への要素の挿入や削除がコンスタントな時間で行えるということです。要素へのアクセスは末端部分では非常に高速ですが、サイズが大きなリストであれば中間部分はとても遅くなり、O(N) になるでしょう。

他にも興味深い機能があるので、紹介しましょう。

* ソーシャルネットワークのタイムラインを構成するときには、タイムラインに新しい要素を追加するために [LPUSH](/commands/lpush) が利用でき、最近のできごとを取得するために [LRANGE](/commands/lrange) が活用できます。
* 最新の N個の要素だけを残し、かつリストの長さを一定に保つためには、[LPUSH](/commands/lpush) と [LTRIM](/commands/ltrim) を組み合わせて使います。
* リスト型はメッセージを渡すプリミティブとしても活用できます。例としては、バックグラウンドジョブを作成するための Rubyライブラリ [Resque](https://github.com/defunkt/resque) があります。
* その他にもリスト型で実現できることがあります。このデータ型では、[BLPOP](/commands/blpop) などのブロッキングコマンドなど、さまざまなコマンドがあります。

他のコマンドは[リストで使えるコマンド群](/commands#list) を参照するか、[Redisデータ型のイントロダクション](/topics/data-types-intro) をお読みください。


<a name="sets"></a>
セット型（Sets）
---

Redis におけるセット型は、順序付けられていない文字列の集合です。O(1)、つまり要素の数に関係なく一定の時間で要素の追加、削除、確認を行うことができます。

セット型では要素の繰り返しを許しません。同じ要素を複数回追加したとしても、この要素の中には一つだけが残ります。これは、*要素を追加するときに存在のチェックが必要ない*ということを意味します。

セット型の非常に興味深い点は、サーバサイドで計算を行うコマンドが幾つも実装されており、セット型について和集合や差集合、差分といった計算を非常に短い時間で実現できることです。

セット型の最大長は 2^32 -1 個の要素（4294967295、つまりセット当たり 4億）です。

セット型で実現できることを考えてみましょう。

* セット型で、ユニークなものを追跡できます。特定のブログ記事を訪れた人の IPアドレスだけを知りたい？その場合は単純に毎回 [SADD](/commands/sadd) を使うことで実現できます。繰り返し同じ IPアドレスが記録されることはありません。
* リレーションを表すことにも長けています。タグ付けを行う仕組みを作り、そのタグをセット型として保存することができます。このときも [SADD](/commands/sadd) を使うことで、特定のタグを持つ要素をすべて追加することができます。3つの異なるタグを持つすべての要素を知りたいときは？[SINTER](/commands/sinter) が役立ちますね。
* セットの要素をランダムに取りたいときは、[SPOP](/commands/spop) や [SRANDMEMBER](/commands/srandmember) といったコマンドが使えます。

その他、[セットコマンドの一覧](/commands#set) や、 [データ型のイントロダクション](/topics/data-types-intro) も参考にしてください。


<a name="hashes"></a>
ハッシュ型（Hashes）
---

ハッシュ型は文字列フィールドと文字列バリューをマッピングするものであり、オブジェクトを格納するのに理想的なものです（例えば、氏名、年齢などといった幾つかのフィールドを持つユーザ等）。

    @cli
    HMSET user:1000 username antirez password P1pp0 age 34
    HGETALL user:1000
    HSET user:1000 password 12345
    HGETALL user:1000

非常に少ないフィールド（大体100程度まで）を持つハッシュ型はとても小さな空間に収まるので、小さな Redisインスタンスであっても数百万といった単位のオブジェクトを格納することができます。

ハッシュ型が使われる場合は、たくさんの要素が格納されていることを意味し、さまざまな他のタスクにも活用できます。

ハッシュ型の最大長は 2^32 -1 個（4億以上）の、フィールドとバリューのペアです。

参考として、[ハッシュコマンドの一覧](/commands#hash) や、 [データ型のイントロダクション](/topics/data-types-intro) もどうぞ。


<a name="sorted-sets"></a>
整列済みセット（Sorted sets）
---

整列済みセットはセット型と同様、重複を許さない文字列の集合です。違いは、すべての要素がスコア順に整列済みである点であり、スコアの最小から最大という順になっています。要素自体は重複を許さずユニークなものですが、スコアは重複する場合があります。

整列済みセットでは、要素の追加、削除、更新は非常に高速に行われます（アルゴリズム上の所要時間は要素数の対数によります）。要素は*順に並んでいて*、後から並べ替えるわけではないので、スコアやランク（の位置）で指定した範囲を非常に高速に取り出すことができます。ソートされたセットの中央部分へのアクセスも十分に高速なので、ユニークな値のリストとして使うこともできます。要素は並んでいて、存在確認も高速で、中央部分へのアクセスも速いことがメリットです。

この種のデータベースでは難しい操作は多くありますが、整列済みセットを用いれば高いパフォーマンスを発揮できることでしょう。

他にも整列済みセットでできることは数多くあります。

* 負荷の高いオンラインゲームで上位の表示を行うための仕組みとして、常に新しいスコアを [ZADD](/commands/zadd) で更新していく方法が考えられます。上位のユーザは [ZRANGE](/commands/zrange) コマンドですぐに取得でき、ユーザ名も取れますし、[ZRANK](/commands/zrank) で順位を表示することもできます。ZRANK/ZRANGE を併用することで、指定したユーザの前後を表示することも可能です。これは*非常に高速に*動作します。
* 整列済みセットは、すでに格納されたデータにインデックスを付ける目的でも多く使われます。例えば、ユーザと対応するたくさんのハッシュ値があるときには、年齢をスコアとし、ユーザID を値にしてみましょう。このときは [ZRANGEBYSCORE](/commands/zrangebyscore) コマンドを使うことで、指定した範囲の年齢のユーザを高速に取り出すことができます。

整列済みセットは Redis の中でも特に発展したデータ型と言えます。ですので、[整列済みセットに関するコマンドの一覧](/commands#sorted_set) や [Redisデータ型の紹介](/topics/data-types-intro) は、できれば時間をかけて読んでいただければと思います。


ビットマップと HyperLogLogs
---

Redis は、文字列データ型をベースとしたものですが、ビットマップと HyperLogLogs も独自にサポートします。

さらなる情報は、[Redisデータ型の紹介](/topics/data-types-intro) などをご覧ください。